// Code generated by go-bindata.
// sources:
// template/custom-resource-definition.yaml
// template/pod-disruption-budget.yaml
// template/redis-bootstrap.json
// template/redis-bootstrap.yaml
// template/redis-service.json
// template/redis-statefulset.json
// template/redis-statefulset.yaml
// template/sentinel-deployment.json
// template/sentinel-service.json
// DO NOT EDIT!

package artifact

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)
type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _templateCustomResourceDefinitionYaml = []byte(`apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: <plural>.<group>
  name: {{.Name}}.{{.Group}}
spec:
  # group name to use for REST API: /apis/<group>/<version>
  group: {{.Group}}
  # version name to use for REST API: /apis/<group>/<version>
  version: {{.Version}}
  # either Namespaced or Cluster
  scope: {{.Scope}}
  names:
    # plural name to be used in the URL: /apis/<group>/<version>/<plural>
    plural: {{.Plural}}
    # singular name to be used as an alias on the CLI and for display
    singular: {{.Singular}}
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: {{.Kind}}
    # shortNames allow shorter string to match your resource on the CLI
`)

func templateCustomResourceDefinitionYamlBytes() ([]byte, error) {
	return _templateCustomResourceDefinitionYaml, nil
}

func templateCustomResourceDefinitionYaml() (*asset, error) {
	bytes, err := templateCustomResourceDefinitionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/custom-resource-definition.yaml", size: 800, mode: os.FileMode(420), modTime: time.Unix(1515541578, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templatePodDisruptionBudgetYaml = []byte(`apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: {{.Name}}
  namespace: {{.Namespace}}
spec:
  # A PDB with pods controlled by another type of controller, by an “operator”, or bare pods has these restrictions:
  #   only .spec.minAvailable can be used, not .spec.maxUnavailable.
  #   only an integer value can be used with .spec.minAvailable, not a percentage.
  minAvailable: {{.MinAvailable}}
  # A label selector .spec.selector to specify the set of pods to which it applies. This field is required. For example:
  # selector:
  #   matchLabels:
  #     app: redis
  #     role: {{.RedisOrSentinel}}
  #     {{.RedisOrSentinel}}: {{.ClusterName}}
  #     isMaster: {{.isMaster}}
  selector: {}
`)

func templatePodDisruptionBudgetYamlBytes() ([]byte, error) {
	return _templatePodDisruptionBudgetYaml, nil
}

func templatePodDisruptionBudgetYaml() (*asset, error) {
	bytes, err := templatePodDisruptionBudgetYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/pod-disruption-budget.yaml", size: 724, mode: os.FileMode(420), modTime: time.Unix(1515640151, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateRedisBootstrapJson = []byte(`{
    "apiVersion": "v1",
    "kind": "Pod",
    "metadata": {
        "labels": {
            "app": "redis",
            "component": "sentinel",
            "sentinel":  "my-redis",
            "bootstrap": "true"
        },
        "name": "redis",
        "namespace": "default"
    },
    "spec": {
        "initContainers": [
            {
                "args": [
                    "-c",
                    "echo -e \"cluster-enabled yes\ncluster-require-full-coverage no\ncluster-node-timeout 15000\ncluster-config-file nodes.conf\ncluster-migration-barrier 1\nappendonly yes\nprotected-mode no\n\">/data/redis.conf; echo -e \"sentinel monitor my-redis 127.0.0.1 6379 2\nsentinel down-after-milliseconds my-redis 60000\nsentinel failover-timeout my-redis 180000\nsentinel parallel-syncs my-redis 1\">/data/sentinel.conf"
                ],
                "command": [ "sh" ],
                "env": [
                    {
                        "name": "REDIS_SENTINEL_HOST",
                        "value": "my-redis"
                    },
                    {
                        "name": "SENTINEL_QUORUM",
                        "value": "2"
                    }
                ],
                "image": "docker.io/redis:4.0-alpine",
                "imagePullPolicy": "IfNotPresent",
                "name": "bootstrap",
                "volumeMounts": [
                    {
                        "mountPath": "/data",
                        "name": "store"
                    }
                ]
            }
        ],
        "containers": [
            {
                "args": ["redis-server", "/data/redis.conf"],
                "command": ["docker-entrypoint.sh"],
                "env": [
                    {
                        "name": "MASTER",
                        "value": "true"
                    }
                ],
                "image": "docker.io/redis:4.0-alpine",
                "imagePullPolicy": "IfNotPresent",
                "name": "redis",
                "ports": [
                    {
                        "containerPort": 6379,
                        "name": "redis",
                        "protocol": "TCP"
                    },
                    {
                        "containerPort": 16379,
                        "name": "gossip",
                        "protocol": "TCP"
                    }
                ],
                "resources": {},
                "readinessProbe": {
                    "exec": {
                        "command": [
                            "sh",
                            "-c",
                            "redis-cli -h $(hostname) ping"
                        ]
                    },
                    "initialDelaySeconds": 15,
                    "timeoutSeconds": 5
                },
                "volumeMounts": [
                    {
                        "mountPath": "/data",
                        "name": "store"
                    }
                ]
            },
            {
                "args": ["redis-server", "/data/sentinel.conf", "--sentinel"],
                "command": ["docker-entrypoint.sh"],
                "env": [
                    {
                        "name": "SENTINEL_QUORUM",
                        "value": "2"
                    },
                    {
                        "name": "SENTINEL",
                        "value": "true"
                    }
                ],
                "image": "docker.io/redis:4.0-alpine",
                "imagePullPolicy": "IfNotPresent",
                "name": "sentinel",
                "ports": [
                    {
                        "containerPort": 26379,
                        "name": "sentinel",
                        "protocol": "TCP"
                    }
                ],
                "resources": {},
                "readinessProbe": {
                    "exec": {
                        "command": [
                            "sh",
                            "-c",
                            "redis-cli -h $(hostname) -p 26379 ping"
                        ]
                    },
                    "initialDelaySeconds": 15,
                    "timeoutSeconds": 5
                },
                "volumeMounts": [
                    {
                        "mountPath": "/data",
                        "name": "store"
                    }
                ]
            }
        ],
        "volumes": [
            {
                "emptyDir": {},
                "name": "store"
            }
        ]
    },
    "status": {}
}
`)

func templateRedisBootstrapJsonBytes() ([]byte, error) {
	return _templateRedisBootstrapJson, nil
}

func templateRedisBootstrapJson() (*asset, error) {
	bytes, err := templateRedisBootstrapJsonBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/redis-bootstrap.json", size: 4636, mode: os.FileMode(420), modTime: time.Unix(1515657228, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateRedisBootstrapYaml = []byte(`apiVersion: v1
kind: Pod
metadata:
    labels:
        app: redis
        component: sentinel
        sentinel:  {{.ClusterName}}
        bootstrap: true
    name: {{.Name}}
    namespace: {{.Namespace}}
spec:
    containers:
      - args:
          - redis-server
          - /data/redis.conf
        command:
          - docker-entrypoint.sh
        env:
          - name: MASTER
            value: 'true'
        image: {{.Image}}
        imagePullPolicy: IfNotPresent
        name: redis
        ports:
          - containerPort: 6379
            name: client
            protocol: TCP
          - containerPort: 16379
            name: gossip
            protocol: TCP
        resources: {}
        readinessProbe:
            exec:
                command:
                  - sh
                  - -c
                  - "redis-cli -h $(hostname) ping"
            initialDelaySeconds: 15
            timeoutSeconds: 5
        volumeMounts:
          - mountPath: /data
            name: store
      - args:
          - redis-server
          - /data/sentinel.conf
          - --sentinel
        command:
          - docker-entrypoint.sh
        env:
          -  name: SENTINEL_QUORUM
             value: '2'
          -  name: SENTINEL
             value: 'true'
        image: {{.Image}}
        imagePullPolicy: IfNotPresent
        name: sentinel
        ports:
          - containerPort: 26379
            name: sentinel
            protocol: TCP
        resources: {}
        readinessProbe:
            exec:
                command:
                  - sh
                  - -c
                  - "redis-cli -h $(hostname) -p 26379 ping"
            initialDelaySeconds: 15
            timeoutSeconds: 5
        volumeMounts:
          - mountPath: /data
            name: store
    initContainers:
      - args:
          - -c
          - "echo -e \"appendonly yes\nprotected-mode no\n\">/data/redis.conf; echo -e \"sentinel monitor {{.ClusterName}} {{.Name}} 6379 {{.SentinelQuorum}}\nsentinel down-after-milliseconds {{.ClusterName}} 60000\nsentinel failover-timeout {{.ClusterName}} 180000\nsentinel parallel-syncs {{.ClusterName}} 1\">/data/sentinel.conf"
        command:
          - sh
        env:
          - name: REDIS_SENTINEL_HOST
            value: {{.ClusterName}}.{{.Namespace}}
          - name: SENTINEL_QUORUM
            value: '{{.SentinelQuorum}}'
        image: {{.Image}}
        imagePullPolicy: IfNotPresent
        name: bootstrap
        volumeMounts:
          - mountPath: /data
            name: store
    volumes:
      - emptyDir: {}
        name: store
status: {}

`)

func templateRedisBootstrapYamlBytes() ([]byte, error) {
	return _templateRedisBootstrapYaml, nil
}

func templateRedisBootstrapYaml() (*asset, error) {
	bytes, err := templateRedisBootstrapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/redis-bootstrap.yaml", size: 2618, mode: os.FileMode(420), modTime: time.Unix(1515718407, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateRedisServiceJson = []byte(`{
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
        "labels": {
            "app": "redis",
            "component": "redis",
            "redis":  "my-redis"
        },
        "name": "redis",
        "namespace": "default"
    },
    "spec": {
        "clusterIP": "None",
        "ports": [
            {
                "name": "client",
                "port": 6379,
                "targetPort": 6379
            },
            {
                "name": "gossip",
                "port": 16379,
                "targetPort": 16379
            }
        ],
        "selector": {
            "app": "redis",
            "component": "redis",
            "redis": "my-redis"
        }
    }
}`)

func templateRedisServiceJsonBytes() ([]byte, error) {
	return _templateRedisServiceJson, nil
}

func templateRedisServiceJson() (*asset, error) {
	bytes, err := templateRedisServiceJsonBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/redis-service.json", size: 719, mode: os.FileMode(420), modTime: time.Unix(1515708280, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateRedisStatefulsetJson = []byte(`{
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
        "labels": {
            "app": "redis",
            "component": "redis",
            "redis":  "my-redis"
        },
        "name": "redis",
        "namespace": "default"
    },
    "spec": {
        "replicas": 2,
        "selector": {
            "matchLabels": {
                "app": "redis",
                "component": "redis",
                "redis": "my-redis"  
            }
        },
        "serviceName": "redis",
        "template": {
            "metadata": {
                "labels": {
                    "app": "redis",
                    "component": "redis",
                    "redis":  "my-redis"
                }  
            },
            "spec": {
                "containers": [
                    {
                        "args": ["redis-server", "/data/redis.conf"],
                        "command": ["docker-entrypoint.sh"],
                        "env": [
                            {
                                "name": "POD_NAME",
                                "valueFrom": {
                                    "fieldRef": {
                                        "fieldPath": "metadata.name"
                                    }
                                }
                            },
                            {
                                "name": "POD_NAMESPACE",
                                "valueFrom": {
                                    "fieldRef": {
                                        "fieldPath": "metadata.namespace"
                                    }
                                }
                            }
                        ],
                        "image": "docker.io/redis:4.0-alpine",
                        "imagePullPolicy": "IfNotPresent",
                        "livenessProbe": {
                            "exec": {
                                "command": [
                                    "sh",
                                    "-c",
                                    "redis-cli -h $(hostname) ping"
                                ]
                            },
                            "initialDelaySeconds": 5,
                            "timeoutSeconds": 5
                        },
                        "name": "redis",
                        "ports": [
                            {
                                "containerPort": 6379,
                                "name": "client",
                                "protocol": "TCP"
                            },
                            {
                                "containerPort": 16379,
                                "name": "gossip",
                                "protocol": "TCP"
                            }
                        ],
                        "resources": {},
                        "readinessProbe": {
                            "exec": {
                                "command": [
                                    "sh",
                                    "-c",
                                    "redis-cli -h $(hostname) ping"
                                ]
                            },
                            "initialDelaySeconds": 15,
                            "timeoutSeconds": 5
                        },
                        "volumeMounts": [
                            {
                                "mountPath": "/data",
                                "name": "store"
                            },
                            {
                                "mountPath": "/podinfo",
                                "name": "podinfo",
                                "readOnly": false
                            }
                        ]
                    }
                ],
                "initContainers": [
                    {
                        "args": [
                            "-c",
                            "for i in $(seq 0 1) ; do sleep 1; master=$(redis-cli -h redis-$i.redis INFO 2>/dev/null); if [ -z \"$master\" ] ; then echo -e \"appendonly yes\nprotected-mode no\">/data/redis.conf; break; elif [ $$(expr index \"$master\" role:master) -gt 0 ] ; then echo -e \"appendonly yes\nprotected-mode no\nslaveof redis-$i.redis 6379\">/data/redis.conf; else master=$$(echo \"$master\" | grep \"master_host\" | cut -d: -f2); echo -e \"appendonly yes\nprotected-mode no\nslaveof $master 6379\">/data/redis.conf; fi ; done"
                        ],
                        "command": [ "sh" ],
                        "env": [
                            {
                                "name": "POD_NAME",
                                "valueFrom": {
                                    "fieldRef": {
                                        "fieldPath": "metadata.name"
                                    }
                                }
                            },
                            {
                                "name": "POD_REPLICAS",
                                "valueFrom": {
                                    "fieldRef": {
                                        "fieldPath": "spec.replicas"
                                    }
                                }
                            }
                        ],
                        "image": "docker.io/redis:4.0-alpine",
                        "imagePullPolicy": "IfNotPresent",
                        "name": "bootstrap",
                        "volumeMounts": [
                            {
                                "mountPath": "/data",
                                "name": "store"
                            },
                            {
                                "mountPath": "/podinfo",
                                "name": "podinfo",
                                "readOnly": false
                            }
                        ]
                    }
                ],
                "volumes": [
                    {
                        "emptyDir": {},
                        "name": "store"
                    },
                    {
                        "downwardAPI": {
                            "items": [
                                {
                                    "fieldRef": {
                                        "fieldPath": "metadata.annotations"
                                    },
                                    "path": "annotations"
                                },
                                {
                                    "fieldRef": {
                                        "fieldPath": "metadata.labels"
                                    },
                                    "path": "labels"
                                },
                                {
                                    "fieldRef": {
                                        "fieldPath": "metadata.name"
                                    },
                                    "path": "name"
                                },
                                {
                                    "fieldRef": {
                                        "fieldPath": "metadata.namespace"
                                    },
                                    "path": "namespace"
                                }
                            ]
                        },
                        "name": "podinfo"
                    }
                ]
            }
        },
        "updateStrategy": {
            "type": "RollingUpdate"
        }
    }
}
`)

func templateRedisStatefulsetJsonBytes() ([]byte, error) {
	return _templateRedisStatefulsetJson, nil
}

func templateRedisStatefulsetJson() (*asset, error) {
	bytes, err := templateRedisStatefulsetJsonBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/redis-statefulset.json", size: 7662, mode: os.FileMode(420), modTime: time.Unix(1515752517, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateRedisStatefulsetYaml = []byte(`apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  labels:
    app: redis
    component: redis
    redis: {{.ClusterName}}
  name: {{.Name}
spec:
  replicas: 2
  selector:
    matchLabels:
      app: redis
      component: redis
      redis: {{.ClusterName}}
  #serviceName: {{.ClusterName}}
  template:
    metadata:
      labels:
        app: redis
        component: redis
        redis: {{.ClusterName}}
      annotations:
        # NOTE: Init container must be idempotent
        # Add a baked-in Redis config file that enables cluster mode
        #pod.alpha.kubernetes.io/init-containers: '[
        #]'
    spec:
      containers:
      - args:
        - redis-server
        - /data/redis.conf
        # Ensure that Redis is online before initializing the next node.
        # TODO: Test that the cluster node is init'd properly.
        command:
        - docker-entrypoint.sh
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        image: {{.Image}}
        imagePullPolicy: IfNotPresent
        # Mark a node as down if Redis server stops running
        livenessProbe:
          exec:
            command:
            - sh
            - -c
            - "redis-cli -h $(hostname) ping"
          initialDelaySeconds: 20
          periodSeconds: 3
        name: redis
        ports:
        - containerPort: 6379
          name: client
          protocol: TCP
        - containerPort: 16379
          name: gossip
          protocol: TCP
        readinessProbe:
          exec:
            command:
            - sh
            - -c
            - "redis-cli -h $(hostname) ping"
          initialDelaySeconds: 15
          timeoutSeconds: 5
        volumeMounts:
        - name: store
          mountPath: /data
          readOnly: false
        - name: podinfo
          mountPath: /etc/podinfo
          readOnly: false
      initContainers:
      - args:
        - -c
        - "echo -e \"cluster-enabled yes\ncluster-require-full-coverage no\ncluster-node-timeout 15000\ncluster-config-file nodes.conf\ncluster-migration-barrier 1\nappendonly yes\nprotected-mode no\nslaveof {{.RedisBootstrapIP}} 6379\n\">/data/redis.conf"
        command:
        - sh
        env:
        - name: REDIS_BOOTSTRAP_IP
          value: {{.RedisBootstrapIP}}
        image: {{.Image}}
        imagePullPolicy: IfNotPresent
        name: bootstrap
        volumeMounts:
        - mountPath: /data
          name: store
      #hostNetwork: true
      terminationGracePeriodSeconds: 10
      volumes:
      # Insert our pre-baked Redis configuration file into /data/redis.conf
      - emptyDir: {}
        name: store
      # The init container will use this info to find cluster peers
      - downwardAPI:
          items:
          - path: "labels"
            fieldRef:
              fieldPath: metadata.labels
          - path: "annotations"
            fieldRef:
              fieldPath: metadata.annotations
          - path: "pod_name"
            fieldRef:
              fieldPath: metadata.name
          - path: "pod_namespace"
            fieldRef:
              fieldPath: metadata.namespace
        name: podinfo
            `)

func templateRedisStatefulsetYamlBytes() ([]byte, error) {
	return _templateRedisStatefulsetYaml, nil
}

func templateRedisStatefulsetYaml() (*asset, error) {
	bytes, err := templateRedisStatefulsetYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/redis-statefulset.yaml", size: 3219, mode: os.FileMode(420), modTime: time.Unix(1515707294, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateSentinelDeploymentJson = []byte(`{
    "apiVersion": "extensions/v1beta1",
    "kind": "Deployment",
    "metadata": {
        "labels": {
            "app": "redis",
            "component": "sentinel",
            "role": "sentinel",
            "sentinel":  "true"
        },
        "name": "{{.Name}}",
        "namespace": "{{.Namespace}}"
    },
    "spec": {
        "replicas": 3,
        "selector": {
            "matchLabels": {
                "app": "redis",
                "component": "sentinel",
                "sentinel": "true"
            }  
        },
        "strategy": {
            "type": "RollingUpdate"
        },
        "template": {
            "metadata": {
                "labels": {
                    "app": "redis",
                    "component": "sentinel",
                    "role": "sentinel",
                    "sentinel":  "true"
                }  
            },
            "spec": {
                "initContainers": [
                    {
                        "command": [ "gen-sentinel-config.sh" ],
                        "env": {
                            "REDIS_SENTINEL_HOST": "{{.Name}}.{{.Namespace}}",
                            "SENTINEL_QUORUM": 2
                        },
                        "image": "{{.Image}}",
                        "imagePullPolicy": "IfNotPresent",
                        "name": "sentinel-config",
                        "volumeMounts": [
                            {
                                "mountPath": "/redis",
                                "name": "config"
                            }
                        ]
                    }
                ],
                "containers": [
                    {
                        "command": [ "redis-server", "/redis/sentinel.conf", "--sentinel" ],
                        "env": {
                            "SENTINEL_QUORUM": 2,
                            "SENTINEL": "true"
                        },
                        "image": "{{.Image}}",
                        "imagePullPolicy": "IfNotPresent",
                        "name": "sentinel",
                        "ports": [
                            {
                                "containerPort": 26379,
                                "name": "sentinel",
                                "protocol": "TCP"
                            }
                        ],
                        "resources": {},
                        "readinessProbe": {
                            "exec": {
                                "command": [
                                    "sh",
                                    "-c",
                                    "redis-cli -h $(hostname) -p 26379 ping"
                                ]
                            },
                            "initialDelaySeconds": 15,
                            "timeoutSeconds": 5
                        },
                        "volumeMounts": [
                            {
                                "mountPath": "/redis",
                                "name": "config"
                            }
                        ]
                    }
                ],
                "volumes": [
                    {
                        "hostPath": {
                            "path": "/tmp",
                            "type": ""
                        },
                        "name": "local"
                    },
                    {
                        "flexVolume": {
                            "driver": "rook.io/rook",
                            "fsType": "ceph",
                            "options": {
                                "clusterName": "rook",
                                "fsName": "myfs"
                            }
                        },
                        "name": "store"
                    },
                    {
                        "emptyDir": {},
                        "name": "snapshots"
                    }
                ]
            }
        }
    },
    "status": {}
}
`)

func templateSentinelDeploymentJsonBytes() ([]byte, error) {
	return _templateSentinelDeploymentJson, nil
}

func templateSentinelDeploymentJson() (*asset, error) {
	bytes, err := templateSentinelDeploymentJsonBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/sentinel-deployment.json", size: 4063, mode: os.FileMode(420), modTime: time.Unix(1515488349, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateSentinelServiceJson = []byte(`{
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
        "labels": {
            "app": "redis",
            "component": "sentinel",
            "role": "service",
            "sentinel":  "true"
        },
        "name": "{{.Name}}",
        "namespace": "{{.Namespace}}"
    },
    "spec": {
        "ports": [
            {
                "name": "sentinel",
                "port": 26379,
                "targetPort": 26379
            }
        ],
        "selector": {
            "app": "redis",
            "component": "sentinel",
            "sentinel": "true"
        }
    }
}`)

func templateSentinelServiceJsonBytes() ([]byte, error) {
	return _templateSentinelServiceJson, nil
}

func templateSentinelServiceJson() (*asset, error) {
	bytes, err := templateSentinelServiceJsonBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/sentinel-service.json", size: 610, mode: os.FileMode(420), modTime: time.Unix(1515459617, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"template/custom-resource-definition.yaml": templateCustomResourceDefinitionYaml,
	"template/pod-disruption-budget.yaml": templatePodDisruptionBudgetYaml,
	"template/redis-bootstrap.json": templateRedisBootstrapJson,
	"template/redis-bootstrap.yaml": templateRedisBootstrapYaml,
	"template/redis-service.json": templateRedisServiceJson,
	"template/redis-statefulset.json": templateRedisStatefulsetJson,
	"template/redis-statefulset.yaml": templateRedisStatefulsetYaml,
	"template/sentinel-deployment.json": templateSentinelDeploymentJson,
	"template/sentinel-service.json": templateSentinelServiceJson,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}
var _bintree = &bintree{nil, map[string]*bintree{
	"template": &bintree{nil, map[string]*bintree{
		"custom-resource-definition.yaml": &bintree{templateCustomResourceDefinitionYaml, map[string]*bintree{}},
		"pod-disruption-budget.yaml": &bintree{templatePodDisruptionBudgetYaml, map[string]*bintree{}},
		"redis-bootstrap.json": &bintree{templateRedisBootstrapJson, map[string]*bintree{}},
		"redis-bootstrap.yaml": &bintree{templateRedisBootstrapYaml, map[string]*bintree{}},
		"redis-service.json": &bintree{templateRedisServiceJson, map[string]*bintree{}},
		"redis-statefulset.json": &bintree{templateRedisStatefulsetJson, map[string]*bintree{}},
		"redis-statefulset.yaml": &bintree{templateRedisStatefulsetYaml, map[string]*bintree{}},
		"sentinel-deployment.json": &bintree{templateSentinelDeploymentJson, map[string]*bintree{}},
		"sentinel-service.json": &bintree{templateSentinelServiceJson, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}

