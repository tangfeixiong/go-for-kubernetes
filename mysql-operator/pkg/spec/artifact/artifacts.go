// Code generated by go-bindata.
// sources:
// template/galera.cnf
// template/galera.cnf.tpl
// template/hostpath-provisioner.yaml
// template/local-storage-provision.yaml
// template/local-volume-admin-account.yaml
// template/local-volume-static-provisioner.yaml
// template/mariadb-service.yaml.tpl
// template/mariadb-statefulset.gotpl.yaml
// template/provision-example.yaml
// DO NOT EDIT!

package artifact

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)
type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _templateGaleraCnf = []byte(`[mysqld]
binlog_format=ROW
default-storage-engine=innodb
innodb_autoinc_lock_mode=2
bind-address=0.0.0.0

# Galera Provider Configuration
wsrep_on=ON
wsrep_provider=/usr/lib/libgalera_smm.so

# Galera Cluster Configuration
wsrep_cluster_name="test_cluster"
wsrep_cluster_address="gcomm://first_ip,second_ip,third_ip"

# Galera Synchronization Configuration
wsrep_sst_method=rsync

# Galera Node Configuration
wsrep_node_address="this_node_ip"
wsrep_node_name="this_node_name"`)

func templateGaleraCnfBytes() ([]byte, error) {
	return _templateGaleraCnf, nil
}

func templateGaleraCnf() (*asset, error) {
	bytes, err := templateGaleraCnfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/galera.cnf", size: 475, mode: os.FileMode(420), modTime: time.Unix(1517449578, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateGaleraCnfTpl = []byte(`[mysqld]
# binlog_format=ROW — see Binary Log Formats
# default_storage_engine=InnoDB
# innodb_autoinc_lock_mode=2
# innodb_doublewrite=1 (the default) when using Galera provider of version >= 2.0.
# query_cache_size=0 (only for versions prior to 5.5.40-galera, 10.0.14-galera and 10.1.2)
binlog_format=ROW
default-storage-engine=innodb
innodb_autoinc_lock_mode=2
bind-address=0.0.0.0

# Galera Provider Configuration
# wsrep_on=ON — Enable wsrep replication (starting 10.1.1)
# wsrep_provider — Path to the Galera library
wsrep_on=ON
wsrep_provider=/usr/lib/libgalera_smm.so

# Galera Cluster Configuration
# wsrep_cluster_name - Defines the logical cluster name for the node. default is example_cluster
# wsrep_cluster_address — see cluster connection URL
# Refer to https://mariadb.com/kb/en/library/getting-started-with-mariadb-galera-cluster/#restarting-the-cluster
# wsrep_provider_options="pc.wait_prim=FALSE" - Default is TRUE, the node waits for the pc.wait_prim_timeout time period. Useful to bring up a non-primary component and make it primary with pc.bootstrap.
# wsrep_provider_options="pc.wait_prim_timeout=PT30S" - The period of time to wait for a primary component.
# wsrep_provider_options="pc.bootstrap=TRUE" - If you set this value to TRUE is a signal to turn a NON-PRIMARY component into PRIMARY.
wsrep_cluster_name="{{.ClusterName}}"
{{if .DisableClusterAddresses}}#{{end}}wsrep_cluster_address="gcomm://{{with .ClusterAddresses}}{{.}}{{end}}{{with .WsrepProviderOptions}}?{{.}}{{end}}"

# Galera Synchronization Configuration
#wsrep_sst_method	mysqldump
wsrep_sst_method=rsync

# Galera Node Configuration
#wsrep_node_address	host address:default port
#wsrep_node_name	<hostname>
{{if .ThisNodeHost}}wsrep_node_address="{{.ThisNodeHost}}"{{end}}
{{if .ThisNodeName}}wsrep_node_name="{{.ThisNodeName}}"{{end}}`)

func templateGaleraCnfTplBytes() ([]byte, error) {
	return _templateGaleraCnfTpl, nil
}

func templateGaleraCnfTpl() (*asset, error) {
	bytes, err := templateGaleraCnfTplBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/galera.cnf.tpl", size: 1839, mode: os.FileMode(420), modTime: time.Unix(1517571239, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateHostpathProvisionerYaml = []byte(`kind: StorageClass
apiVersion: storage.k8s.io/v1beta1
metadata:
  name: example-hostpath
provisioner: example.com/hostpath
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: hostpath-admin
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: hostpath-provisioner-pv-binding
  namespace: default
subjects:
- kind: ServiceAccount
  name: hostpath-admin
  namespace: default
roleRef:
  kind: ClusterRole
  name: system:persistent-volume-provisioner
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: hostpath-provisioner-node-binding
  namespace: default
subjects:
- kind: ServiceAccount
  name: hostpath-admin
  namespace: default
roleRef:
  kind: ClusterRole
  name: system:node
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: extensions/v1beta1
kind: DaemonSet
metadata:
  name: hostpath-provisioner
  labels:
    app: hostpath-provisioner
spec:
  selector:
    matchLabels:
      app: hostpath-provisioner 
  template:
    metadata:
      labels:
        app: hostpath-provisioner
    spec:
      containers:
        - name: hostpath-provisioner
          image: docker.io/tangfeixiong/hostpath-provisioner:latest
          imagePullPolicy: "IfNotPresent"
          env:
            - name: NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          volumeMounts:
            - name: pv-volume
              mountPath: /tmp/hostpath-provisioner
      serviceAccountName: hostpath-admin
      volumes:
        - name: pv-volume
          hostPath:
            path: /tmp/hostpath-provisioner
---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: hostpath
  annotations:
    volume.beta.kubernetes.io/storage-class: "example-hostpath"
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 1Mi
`)

func templateHostpathProvisionerYamlBytes() ([]byte, error) {
	return _templateHostpathProvisionerYaml, nil
}

func templateHostpathProvisionerYaml() (*asset, error) {
	bytes, err := templateHostpathProvisionerYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/hostpath-provisioner.yaml", size: 1920, mode: os.FileMode(420), modTime: time.Unix(1517439085, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateLocalStorageProvisionYaml = []byte(`# https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume
# Only create this for K8s 1.9+
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
---
# If static provisioner is installed, do not prebind through pv
apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-local-pv
  annotations:
    "volume.alpha.kubernetes.io/node-affinity": '{
      "requiredDuringSchedulingIgnoredDuringExecution": {
        "nodeSelectorTerms": [
          { "matchExpressions": [
            { "key": "kubernetes.io/hostname",
              "operator": "In",
              "values": ["rookdev-172-17-4-61", "rookdev-172-17-4-63"]
            }
          ]}
         ]}
        }'
spec:
  capacity:
    storage: 60Mi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /mnt/disks/vol1
---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: example-local-claim
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 50Mi
  storageClassName: local-storage`)

func templateLocalStorageProvisionYamlBytes() ([]byte, error) {
	return _templateLocalStorageProvisionYaml, nil
}

func templateLocalStorageProvisionYaml() (*asset, error) {
	bytes, err := templateLocalStorageProvisionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/local-storage-provision.yaml", size: 1191, mode: os.FileMode(420), modTime: time.Unix(1517439458, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateLocalVolumeAdminAccountYaml = []byte(`apiVersion: v1
kind: ServiceAccount
metadata:
  name: local-storage-admin
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: local-storage-provisioner-pv-binding
  namespace: default
subjects:
- kind: ServiceAccount
  name: local-storage-admin
  namespace: default
roleRef:
  kind: ClusterRole
  name: system:persistent-volume-provisioner
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: local-storage-provisioner-node-binding
  namespace: default
subjects:
- kind: ServiceAccount
  name: local-storage-admin
  namespace: default
roleRef:
  kind: ClusterRole
  name: system:node
  apiGroup: rbac.authorization.k8s.io
`)

func templateLocalVolumeAdminAccountYamlBytes() ([]byte, error) {
	return _templateLocalVolumeAdminAccountYaml, nil
}

func templateLocalVolumeAdminAccountYaml() (*asset, error) {
	bytes, err := templateLocalVolumeAdminAccountYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/local-volume-admin-account.yaml", size: 741, mode: os.FileMode(420), modTime: time.Unix(1517433168, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateLocalVolumeStaticProvisionerYaml = []byte(`---
# Source: provisioner/templates/provisioner.yaml
 
apiVersion: v1
kind: ConfigMap
metadata:
  name: local-provisioner-config 
  namespace: default 
data:
  storageClassMap: |     
    fast-disks:
       hostDir: /mnt/fast-disks
       mountDir:  /mnt/fast-disks  
---
apiVersion: extensions/v1beta1
kind: DaemonSet
metadata:
  name: local-volume-provisioner
  namespace: default
  labels:
    app: local-volume-provisioner
spec:
  selector:
    matchLabels:
      app: local-volume-provisioner 
  template:
    metadata:
      labels:
        app: local-volume-provisioner
    spec:
      serviceAccountName: local-storage-admin
      containers:
        - image: "quay.io/external_storage/local-volume-provisioner:latest"
          imagePullPolicy: "Always"
          name: provisioner 
          securityContext:
            privileged: true
          env:
          - name: MY_NODE_NAME
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
          volumeMounts:
            - mountPath: /etc/provisioner/config 
              name: provisioner-config
              readOnly: true             
            - mountPath:  /mnt/fast-disks 
              name: fast-disks 
      volumes:
        - name: provisioner-config
          configMap:
            name: local-provisioner-config         
        - name: fast-disks
          hostPath:
            path: /mnt/fast-disks 

`)

func templateLocalVolumeStaticProvisionerYamlBytes() ([]byte, error) {
	return _templateLocalVolumeStaticProvisionerYaml, nil
}

func templateLocalVolumeStaticProvisionerYaml() (*asset, error) {
	bytes, err := templateLocalVolumeStaticProvisionerYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/local-volume-static-provisioner.yaml", size: 1418, mode: os.FileMode(420), modTime: time.Unix(1517433205, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateMariadbServiceYamlTpl = []byte(`apiVersion: v1
kind: Service
metadata:
  labels:
    app: mariadb
    component: mariadb-galera
    example.com/mysql-operator: {{.CustomResourceName}} # operator reserved!
  name: {{.Name}} # e.g. demo-mariadb-galera
  #namespace: default
spec:
  clusterIP: None
  ports:
  - name: client
    port: 3306
    protocol: TCP
    targetPort: 3306
  - name: traffic
    port: 4567
    protocol: TCP
    targetPort: 4567
  - name: trafficu
    port: 4567
    protocol: UDP
    targetPort: 4567
  - name: ist
    port: 4568
    protocol: TCP
    targetPort: 4568
  - name: sst
    port: 4444
    protocol: TCP
    targetPort: 4444
  selector:
    app: mariadb
    component: mariadb-galera
    example.com/mysql-operator: {{.CustomResourceName}} # required by operator itself!
  #sessionAffinity: None
  #sessionAffinity: ClientIP
  #type: ClusterIP`)

func templateMariadbServiceYamlTplBytes() ([]byte, error) {
	return _templateMariadbServiceYamlTpl, nil
}

func templateMariadbServiceYamlTpl() (*asset, error) {
	bytes, err := templateMariadbServiceYamlTplBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/mariadb-service.yaml.tpl", size: 843, mode: os.FileMode(420), modTime: time.Unix(1517531271, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateMariadbStatefulsetGotplYaml = []byte(`apiVersion: apps/v1beta2
kind: StatefulSet
metadata:
  labels:
    app: mariadb
    component: mariadb-galera
    example.com/mysql-operator: {{.CustomResourceName}} # required by operator itself!
  name: {{.Name}} # e.g. demo-mariadb-galera
  #namespace: default
spec:
  podManagementPolicy: OrderedReady
  #podManagementPolicy: Parallel
  replicas: {{.Count}}
  selector:
    matchLabels:
      app: mariadb
      component: mariadb-galera
      example.com/mysql-operator: {{.CustomResourceName}} # required by operator itself!
  serviceName: {{.ServiceName}} # e.g. demo-mariadb-galera
  template:
    metadata:
      labels:
        app: mariadb
        component: mariadb-galera
        app-affinity: local-test-affinity
        example.com/go-to-kubernetes: {{.Name}} # required by operator itself!
        example.com/mysql-operator: {{.CustomResourceName}} # required by operator itself!
    spec:
      #affinity:
      #  podAffinity:
      #    requiredDuringSchedulingIgnoredDuringExecution:
      #    - labelSelector:
      #        matchExpressions:
      #        - key: app-affinity
      #          operator: In
      #          values:
      #          - local-test-affinity
      #      topologyKey: kubernetes.io/hostname
      #affinity:
      #  podAntiAffinity:
      #    requiredDuringSchedulingIgnoredDuringExecution:
      #    - labelSelector:
      #        matchExpressions:
      #        - key: app-affinity
      #          operator: In
      #          values:
      #          - local-test-anti-affinity
      #      topologyKey: kubernetes.io/hostname
      containers:
      - args: ["/operator-entrypoint/mysql-operator", "agent"]
        #- mysqld
        command: ["/operator-entrypoint/tini", "-g", "--"]
        #- /usr/local/bin/docker-entrypoint.sh
        env:
        - name: MYSQL_USER
          value: {{.MysqlUser}}  
        - name: MYSQL_PASSWORD
          value: {{.MysqlPassword}}  
        #- name: MYSQL_PASSWORD_FILE
        #  value: /run/secrets/mysql-user  
        - name: MYSQL_DATABASE
          value: {{.MysqlDatabase}}  
        - name: MYSQL_ROOT_PASSWORD
          value: {{.MysqlRootPassword}}  
        #- name: MYSQL_ROOT_PASSWORD_FILE
        #  value: /run/secrets/mysql-root
        image: docker.io/mariadb:10.2
        imagePullPolicy: IfNotPresent
        #livenessProbe:
        #  exec:
        #    command:
        #    - mysqladmin
        #    - --password={{.MysqlRootPassword}}
        #    - ping
        #  failureThreshold: 3
        #  initialDelaySeconds: 5
        #  periodSeconds: 10
        #  successThreshold: 1
        #  timeoutSeconds: 5
        name: mariadb-galera
        ports:
        - containerPort: 3306
          name: client
          protocol: TCP
        #readinessProbe:
        #  exec:
        #    command:
        #    - mysqladmin
        #    - --password={{.MysqlRootPassword}}
        #    - ping
        #  failureThreshold: 3
        #  initialDelaySeconds: 15
        #  periodSeconds: 10
        #  successThreshold: 1
        #  timeoutSeconds: 5
        resources: {}
        securityContext:
          privileged: true
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /docker-entrypoint-initdb.d
          name: initdb
        - mountPath: /etc/mysql/mariadb.conf.d
          name: confd
        - mountPath: /operator-entrypoint
          name: operatorentry
        - mountPath: /var/lib/mysql
          #name: local-vol
          name: hostpath
      dnsPolicy: ClusterFirst
      initContainers:
      - args:
        - --conf_dir=/etc/mysql/mariadb.conf.d
        - --logtostderr
        - --v=5
        command:
        - /mysql-operator
        - init
        env:
        - name: MY_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: MY_POD_NAME  # important, required to discover StatefulSet name by operator itself!
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: MY_POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: MY_POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: MY_POD_SERVICE_ACCOUNT
          valueFrom:
            fieldRef:
              fieldPath: spec.serviceAccountName
        - name: CLUSTER_NAME
          value: {{.ClusterName}}
        image: docker.io/tangfeixiong/mysql-operator        
        #imagePullPolicy: IfNotPresent
        imagePullPolicy: Always
        name: preboot
        resources: {}
        securityContext:
          privileged: true
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /docker-entrypoint-initdb.d
          name: initdb
        - mountPath: /etc/mysql/mariadb.conf.d
          name: confd
        - mountPath: /operator-entrypoint
          name: operatorentry
        - mountPath: /operator-initdb
          name: operatorinitdb
        - mountPath: /podinfo
          name: podinfo
      #restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      #securityContext:
      #  fsGroup: 1234
      terminationGracePeriodSeconds: 30
      volumes:
      - downwardAPI:
          defaultMode: 420
          items:
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.annotations
            path: annotations
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.labels
            path: labels
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
            path: name
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
            path: namespace
        name: podinfo
      - emptyDir: {}
        name: confd
      - emptyDir: {}
        name: initdb
      - emptyDir: {}
        name: operatorentry
      - name: operatorinitdb
        persistentVolumeClaim:
          claimName: example-local-claim
  updateStrategy:
    #type: RollingUpdate
    type: OnDelete
  volumeClaimTemplates:
  #- metadata:
  #    name: local-vol
  #  spec:
  #    accessModes: [ "ReadWriteOnce" ]
  #    storageClassName: "local-storage"
  #    resources:
  #      requests:
  #        storage: 100Mi
  #- metadata:
  #    name: mysql-pv-claim
  #  spec:
  #    accessModes:
  #    - ReadWriteOnce
  #    resources:
  #      requests:
  #        storage: 20Gi
  #    storageClassName: rook-block
  - metadata:
      name: hostpath
      #annotations:
      #  volume.beta.kubernetes.io/storage-class: "example-hostpath"
    spec:
      accessModes:
        - ReadWriteOnce
        #- ReadOnlyMany
        #- ReadWriteMany
      storageClassName: "example-hostpath"
      resources:
        requests:
          storage: 80Mi
    `)

func templateMariadbStatefulsetGotplYamlBytes() ([]byte, error) {
	return _templateMariadbStatefulsetGotplYaml, nil
}

func templateMariadbStatefulsetGotplYaml() (*asset, error) {
	bytes, err := templateMariadbStatefulsetGotplYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/mariadb-statefulset.gotpl.yaml", size: 6980, mode: os.FileMode(420), modTime: time.Unix(1519277891, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateProvisionExampleYaml = []byte(`apiVersion: example.com/v1alpha1
kind: Mariadb
metadata:
  name: my-galera
spec:
  # Optional, default is docker.io/mariadb:10, must suppport:
  #   mariadb:10.1, mariadb:10.0
  #   mysql:5
  #   mysql:5.7, mysql:5.6, mysql:5.5
  # May support:
  #   mariadb:5
  # Plan to support custome image, for example:
  # image:
  #   nameValues:
  #   - name: version
  #     value: mariadb10.2
  #   docker: 'docker.io/tangfeixiong/mariadb:latest'
  #image: {}
  # Follow https://mariadb.com/kb/en/library/what-is-mariadb-galera-cluster/
  #   clusterMode: Galera, Replication
  # Follow https://dev.mysql.com/downloads/cluster/
  #   clusterMode: CGE, Replication
  # No clustering
  #   clusterMode: None
  #clusterMode: Galera
  mysqlTemplate: {}
  galeraTemplate:
    # According documention, https://mariadb.com/kb/en/library/getting-started-with-mariadb-galera-cluster/
    # Thus total members of cluster, minimal value is 3
    count: 3
    # According documention, http://galeracluster.com/documentation-webpages/mysqlwsrepoptions.html#wsrep-cluster-name
    #clusterName: example_cluster`)

func templateProvisionExampleYamlBytes() ([]byte, error) {
	return _templateProvisionExampleYaml, nil
}

func templateProvisionExampleYaml() (*asset, error) {
	bytes, err := templateProvisionExampleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/provision-example.yaml", size: 1090, mode: os.FileMode(420), modTime: time.Unix(1517533275, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"template/galera.cnf": templateGaleraCnf,
	"template/galera.cnf.tpl": templateGaleraCnfTpl,
	"template/hostpath-provisioner.yaml": templateHostpathProvisionerYaml,
	"template/local-storage-provision.yaml": templateLocalStorageProvisionYaml,
	"template/local-volume-admin-account.yaml": templateLocalVolumeAdminAccountYaml,
	"template/local-volume-static-provisioner.yaml": templateLocalVolumeStaticProvisionerYaml,
	"template/mariadb-service.yaml.tpl": templateMariadbServiceYamlTpl,
	"template/mariadb-statefulset.gotpl.yaml": templateMariadbStatefulsetGotplYaml,
	"template/provision-example.yaml": templateProvisionExampleYaml,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}
var _bintree = &bintree{nil, map[string]*bintree{
	"template": &bintree{nil, map[string]*bintree{
		"galera.cnf": &bintree{templateGaleraCnf, map[string]*bintree{}},
		"galera.cnf.tpl": &bintree{templateGaleraCnfTpl, map[string]*bintree{}},
		"hostpath-provisioner.yaml": &bintree{templateHostpathProvisionerYaml, map[string]*bintree{}},
		"local-storage-provision.yaml": &bintree{templateLocalStorageProvisionYaml, map[string]*bintree{}},
		"local-volume-admin-account.yaml": &bintree{templateLocalVolumeAdminAccountYaml, map[string]*bintree{}},
		"local-volume-static-provisioner.yaml": &bintree{templateLocalVolumeStaticProvisionerYaml, map[string]*bintree{}},
		"mariadb-service.yaml.tpl": &bintree{templateMariadbServiceYamlTpl, map[string]*bintree{}},
		"mariadb-statefulset.gotpl.yaml": &bintree{templateMariadbStatefulsetGotplYaml, map[string]*bintree{}},
		"provision-example.yaml": &bintree{templateProvisionExampleYaml, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}

