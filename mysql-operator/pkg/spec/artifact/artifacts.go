// Code generated by go-bindata.
// sources:
// template/galera.cnf
// template/galera.cnf.tpl
// template/local-storage-provision.yaml
// template/mariadb-service.yaml.tpl
// template/mariadb-statefulset.yaml.tpl
// DO NOT EDIT!

package artifact

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)
type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _templateGaleraCnf = []byte(`[mysqld]
binlog_format=ROW
default-storage-engine=innodb
innodb_autoinc_lock_mode=2
bind-address=0.0.0.0

# Galera Provider Configuration
wsrep_on=ON
wsrep_provider=/usr/lib/galera/libgalera_smm.so

# Galera Cluster Configuration
wsrep_cluster_name="test_cluster"
wsrep_cluster_address="gcomm://first_ip,second_ip,third_ip"

# Galera Synchronization Configuration
wsrep_sst_method=rsync

# Galera Node Configuration
wsrep_node_address="this_node_ip"
wsrep_node_name="this_node_name"`)

func templateGaleraCnfBytes() ([]byte, error) {
	return _templateGaleraCnf, nil
}

func templateGaleraCnf() (*asset, error) {
	bytes, err := templateGaleraCnfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/galera.cnf", size: 482, mode: os.FileMode(420), modTime: time.Unix(1516949888, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateGaleraCnfTpl = []byte(`[mysqld]
# binlog_format=ROW — see Binary Log Formats
# default_storage_engine=InnoDB
# innodb_autoinc_lock_mode=2
# innodb_doublewrite=1 (the default) when using Galera provider of version >= 2.0.
# query_cache_size=0 (only for versions prior to 5.5.40-galera, 10.0.14-galera and 10.1.2)
binlog_format=ROW
default-storage-engine=innodb
innodb_autoinc_lock_mode=2
bind-address=0.0.0.0

# Galera Provider Configuration
# wsrep_on=ON — Enable wsrep replication (starting 10.1.1)
# wsrep_provider — Path to the Galera library
wsrep_on=ON
wsrep_provider=/usr/lib/galera/libgalera_smm.so

# Galera Cluster Configuration
#wsrep_cluster_name	example_cluster
# wsrep_cluster_address — see cluster connection URL
wsrep_cluster_name="{{.ClusterName}}"
{{if .DisableClusterAddresses}}#{{end}}wsrep_cluster_address="gcomm://{{with .ClusterAddresses}}{{.}}{{else}}{{.FirstNodeHost}},{{.SecondNodeHost}},{{.ThirdNodeHost}}{{end}}"

# Galera Synchronization Configuration
#wsrep_sst_method	mysqldump
wsrep_sst_method=rsync

# Galera Node Configuration
#wsrep_node_address	host address:default port
#wsrep_node_name	<hostname>
{{if .ThisNodeHost}}wsrep_node_address="{{.ThisNodeHost}}"{{end}}
{{if .ThisNodeName}}wsrep_node_name="{{.ThisNodeName}}"{{end}}`)

func templateGaleraCnfTplBytes() ([]byte, error) {
	return _templateGaleraCnfTpl, nil
}

func templateGaleraCnfTpl() (*asset, error) {
	bytes, err := templateGaleraCnfTplBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/galera.cnf.tpl", size: 1247, mode: os.FileMode(420), modTime: time.Unix(1517161389, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateLocalStorageProvisionYaml = []byte(`# https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume
# Only create this for K8s 1.9+
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-local-pv
  annotations:
    "volume.alpha.kubernetes.io/node-affinity": '{
      "requiredDuringSchedulingIgnoredDuringExecution": {
        "nodeSelectorTerms": [
          { "matchExpressions": [
            { "key": "kubernetes.io/hostname",
              "operator": "In",
              "values": ["rookdev-172-17-4-61", "rookdev-172-17-4-63"]
            }
          ]}
         ]}
        }'
spec:
  capacity:
    storage: 60Mi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /mnt/disks/vol1
---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: example-local-claim
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 50Mi
  storageClassName: local-storage`)

func templateLocalStorageProvisionYamlBytes() ([]byte, error) {
	return _templateLocalStorageProvisionYaml, nil
}

func templateLocalStorageProvisionYaml() (*asset, error) {
	bytes, err := templateLocalStorageProvisionYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/local-storage-provision.yaml", size: 1127, mode: os.FileMode(420), modTime: time.Unix(1517418782, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateMariadbServiceYamlTpl = []byte(`apiVersion: v1
kind: Service
metadata:
  labels:
    app: mariadb
    component: mariadb-galera
    example.com/mysql-operator: {{.CustomResourceName}} # operator reserved!
  name: {{.Name}} # e.g. demo-mariadb-galera
  #namespace: default
spec:
  #clusterIP: None
  ports:
  - name: client
    port: 3306
    protocol: TCP
    targetPort: 3306
  - name: traffic
    port: 4567
    protocol: TCP
    targetPort: 4567
  - name: trafficu
    port: 4567
    protocol: UDP
    targetPort: 4567
  - name: ist
    port: 4568
    protocol: TCP
    targetPort: 4568
  - name: sst
    port: 4444
    protocol: TCP
    targetPort: 4444
  selector:
    app: mariadb
    component: mariadb-galera
    example.com/mysql-operator: {{.CustomResourceName}} # required by operator itself!
  #sessionAffinity: None
  #sessionAffinity: ClientIP
  #type: ClusterIP`)

func templateMariadbServiceYamlTplBytes() ([]byte, error) {
	return _templateMariadbServiceYamlTpl, nil
}

func templateMariadbServiceYamlTpl() (*asset, error) {
	bytes, err := templateMariadbServiceYamlTplBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/mariadb-service.yaml.tpl", size: 844, mode: os.FileMode(420), modTime: time.Unix(1517384688, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _templateMariadbStatefulsetYamlTpl = []byte(`apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: mariadb
    component: mariadb-galera
    example.com/mysql-operator: {{.CustomResourceName}} # required by operator itself!
  name: {{.Name}} # e.g. demo-mariadb-galera
  #namespace: default
spec:
  podManagementPolicy: OrderedReady
  replicas: {{.Count}}
  selector:
    matchLabels:
      app: mariadb
      component: mariadb-galera
      example.com/mysql-operator: {{.CustomResourceName}} # required by operator itself!
  serviceName: {{.ServiceName}} # e.g. demo-mariadb-galera
  template:
    metadata:
      labels:
        app: mariadb
        component: mariadb-galera
        app-affinity: local-test-affinity
        example.com/go-to-kubernetes: {{.Name}} # required by operator itself!
        example.com/mysql-operator: {{.CustomResourceName}} # required by operator itself!
    spec:
      #affinity:
      #  podAffinity:
      #    requiredDuringSchedulingIgnoredDuringExecution:
      #    - labelSelector:
      #        matchExpressions:
      #        - key: app-affinity
      #          operator: In
      #          values:
      #          - local-test-affinity
      #      topologyKey: kubernetes.io/hostname
      #affinity:
      #  podAntiAffinity:
      #    requiredDuringSchedulingIgnoredDuringExecution:
      #    - labelSelector:
      #        matchExpressions:
      #        - key: app-affinity
      #          operator: In
      #          values:
      #          - local-test-anti-affinity
      #      topologyKey: kubernetes.io/hostname
      containers:
      - args:
        - mysqld
        command:
        - docker-entrypoint.sh
        env:
        - name: MYSQL_USER
          value: {{.MysqlUser}}  
        - name: MYSQL_PASSWORD
          value: {{.MysqlPassword}}  
        #- name: MYSQL_PASSWORD_FILE
        #  value: /run/secrets/mysql-user  
        - name: MYSQL_DATABASE
          value: {{.MysqlDatabase}}  
        - name: MYSQL_ROOT_PASSWORD
          value: {{.MysqlRootPassword}}  
        #- name: MYSQL_ROOT_PASSWORD_FILE
        #  value: /run/secrets/mysql-root
        - name: POD_NAME
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
        image: docker.io/mariadb:10.2
        imagePullPolicy: IfNotPresent
        livenessProbe:
          exec:
            command:
            - mysqladmin
            - ping
          failureThreshold: 3
          initialDelaySeconds: 5
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 5
        name: mariadb-galera
        ports:
        - containerPort: 3306
          name: client
          protocol: TCP
        readinessProbe:
          exec:
            command:
            - mysqladmin
            - ping
          failureThreshold: 3
          initialDelaySeconds: 15
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 5
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /docker-entrypoint-initdb.d
          name: initdb
        - mountPath: /var/lib/mysql
          name: local-vol
        - mountPath: /podinfo
          name: podinfo
      dnsPolicy: ClusterFirst
      initContainers:
      - args:
        - init
        - --conf_dir=/etc/mysql/conf.d
        command:
        - /mysql-operator
        env:
        - name: MY_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: MY_POD_NAME  # important, required to discover StatefulSet name by operator itself!
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: MY_POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: MY_POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        #- name: MY_POD_SERVICE_ACCOUNT
        #  valueFrom:
        #    fieldRef:
        #      fieldPath: spec.serviceAccountName
        - name: CLUSTER_NODES
          value: "3"
        image: docker.io/tangfeixiong/mysql-operator
        imagePullPolicy: IfNotPresent
        name: initcnf
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /docker-entrypoint-initdb.d
          name: initdb
        - mountPath: /tmp/docker-entrypoint-initdb.d
          name: initscripts
        - mountPath: /podinfo
          name: podinfo
      restartPolicy: Always
      schedulerName: default-scheduler
      #securityContext: {}
      securityContext:
        fsGroup: 1234
      terminationGracePeriodSeconds: 30
      volumes:
      - emptyDir: {}
        name: initdb
      #- hostPath:
      #    path: /path/from/host
      #  name: initscripts
      - name: initscripts
        persistentVolumeClaim:
          claimName: example-local-claim
      - downwardAPI:
          defaultMode: 420
          items:
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.annotations
            path: annotations
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.labels
            path: labels
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
            path: name
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
            path: namespace
        name: podinfo
  updateStrategy:
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      name: local-vol
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: "local-storage"
      resources:
        requests:
          storage: 100Mi
    `)

func templateMariadbStatefulsetYamlTplBytes() ([]byte, error) {
	return _templateMariadbStatefulsetYamlTpl, nil
}

func templateMariadbStatefulsetYamlTpl() (*asset, error) {
	bytes, err := templateMariadbStatefulsetYamlTplBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "template/mariadb-statefulset.yaml.tpl", size: 5842, mode: os.FileMode(420), modTime: time.Unix(1517388541, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"template/galera.cnf": templateGaleraCnf,
	"template/galera.cnf.tpl": templateGaleraCnfTpl,
	"template/local-storage-provision.yaml": templateLocalStorageProvisionYaml,
	"template/mariadb-service.yaml.tpl": templateMariadbServiceYamlTpl,
	"template/mariadb-statefulset.yaml.tpl": templateMariadbStatefulsetYamlTpl,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}
var _bintree = &bintree{nil, map[string]*bintree{
	"template": &bintree{nil, map[string]*bintree{
		"galera.cnf": &bintree{templateGaleraCnf, map[string]*bintree{}},
		"galera.cnf.tpl": &bintree{templateGaleraCnfTpl, map[string]*bintree{}},
		"local-storage-provision.yaml": &bintree{templateLocalStorageProvisionYaml, map[string]*bintree{}},
		"mariadb-service.yaml.tpl": &bintree{templateMariadbServiceYamlTpl, map[string]*bintree{}},
		"mariadb-statefulset.yaml.tpl": &bintree{templateMariadbStatefulsetYamlTpl, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}

